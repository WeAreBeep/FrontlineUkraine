using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Web.Db.Auditing;

namespace Web.Db
{
	public partial class DataContext
	{
		public virtual DbSet<Audit> Audits { get; set; }

		void configureAuditing(ModelBuilder mb)
		{
			mb.Entity<Audit>(ent =>
			{
				ent.Property(e => e.Timestamp).IsRequired();
				ent.Property(e => e.Username).HasMaxLength(256).HasColumnName("UserName");
				ent.Property(e => e.TableName).IsRequired().HasMaxLength(128);
				ent.Property(e => e.Action).IsRequired().HasMaxLength(50);
			});
		}

		public override int SaveChanges()
		{
			throw new NotImplementedException("Use overload with username"); //IdentityContext is ALL async ?? 
		}

		public int SaveChanges(string userName, bool inhibitAudit = false)
		{
			int result;
			if(inhibitAudit)
			{
				result = base.SaveChanges();
			}
			else
			{
				DateTimeOffset now = DateTimeOffset.UtcNow;
				List<AuditEntry> auditEntries = beforeSaveChanges(userName, now);
				result = base.SaveChanges();
				afterSaveChanges(auditEntries, userName, now);
			}
			return result;
		}

		List<AuditEntry> beforeSaveChanges(string userName, DateTimeOffset now)
		{
			List<AuditEntry> auditEntries = new List<AuditEntry>();
			foreach(EntityEntry entry in ChangeTracker.Entries())
			{
				if(entry.Entity is Audit || entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
					continue;

				AuditEntry auditEntry = new AuditEntry(entry);
				auditEntry.TableName = entry.Metadata.GetTableName(); //entry.Metadata.Relational().TableName;
				auditEntries.Add(auditEntry);

				foreach(var property in entry.Properties)
				{
					if(property.IsTemporary)
					{
						auditEntry.TemporaryProperties.Add(property); // value will be generated by the database, get the value after saving
						continue;
					}

					string propertyName = property.Metadata.Name;
					if(property.Metadata.IsPrimaryKey())
					{
						auditEntry.KeyValues[propertyName] = property.CurrentValue;
						continue;
					}

					switch(entry.State)
					{
						case EntityState.Added:
							auditEntry.NewValues[propertyName] = property.CurrentValue;
							auditEntry.ChangeType = ChangeTypes.Create;
							break;

						case EntityState.Deleted:
							auditEntry.OldValues[propertyName] = property.OriginalValue;
							auditEntry.ChangeType = ChangeTypes.Delete;
							break;

						case EntityState.Modified:
							auditEntry.ChangeType = ChangeTypes.Update;
							if(property.IsModified)
							{
								auditEntry.OldValues[propertyName] = property.OriginalValue;
								auditEntry.NewValues[propertyName] = property.CurrentValue;
							}
							break;
					}
				}
			}

			foreach(AuditEntry auditEntry in auditEntries.Where(_ => !_.HasTemporaryProperties))
			{
				Audits.Add(auditEntry.ToAudit(userName, now)); // Save audit entities that have all the modifications
			}

			return auditEntries.Where(_ => _.HasTemporaryProperties).ToList(); // keep a list of entries where the value of some properties are unknown at this step
		}

		void afterSaveChanges(List<AuditEntry> auditEntries, string userName, DateTimeOffset now)
		{
			if(auditEntries == null || auditEntries.Count == 0)
				return;

			foreach(AuditEntry auditEntry in auditEntries)
			{
				foreach(PropertyEntry prop in auditEntry.TemporaryProperties) // Get the final value of the temporary properties
				{
					if(prop.Metadata.IsPrimaryKey())
					{
						auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
					}
					else
					{
						auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
					}
				}
				Audits.Add(auditEntry.ToAudit(userName, now));
			}
			base.SaveChanges(); // Save the Audit entries
		}
	}
}